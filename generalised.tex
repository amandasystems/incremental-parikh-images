The Parikh map~$\ParikhMap$ represents a homomorphism from the (free)
non-commutative monoid~$\Strings$ to the (free) commutative
monoid~$\Naturals^k$. We are, however, often interested in projections of the
Parikh map, rather than the full image. We therefore consider \emph{arbitrary}
homomorphisms $\Map:\: \Sigma^* \to \Monoid$, where $\Monoid =
\left(X;\MonoidOp;0_{\Monoid}\right)$ is a commutative monoid. We give several
examples of such projections on Parikh images later in this section.

Observe that every homomorphism~$\Map:\: \Sigma^* \to \Monoid$ can be
represented as the composition~$h' \circ \ParikhMap$, for some
homomorphism~$h' : \Naturals^k \to M$. One of the insights underlying our
approach is that it is more efficient to directly compute a
projection~$\Map(\Language)$ on the Parikh image, than to first compute the
standard image~$\ParikhMap(\Language)$ followed by projection to
some property of interest.


\begin{example}[String Length]\label{ex:length}
One such simplifying homomorphism can express string
length, the problem that originally motivated our study of the Parikh
map. This mapping is relevant when solving constraints that combine
language membership with string length, for instance the constraint
given in the introduction:
\begin{equation}\label{eq:stringLength}
x \in \Language_1 \wedge y \in \Language_2 \wedge |x| > |y|
\end{equation}

To solve this formula, let
$\Monoid = \Naturals$, and define the homomorphism~$L$ by $L(a) = 1$
for all characters~$a \in \Alphabet$. The length of a string
$s = s_1 \RepeatSum{\Concat} s_n$ is given by
$L(s) = \sum L(s_i) = 1 \RepeatSum{+} 1 = n$, and to solve
\eqref{eq:stringLength} we can instead solve the equi-satisfiable
formula~$\alpha \in L(\Language_1) \wedge \beta \in L(\Language_2)
\wedge \alpha > \beta$. This paper proposes efficient native
procedures to reason about membership constraints
like~$\alpha \in L(\Language_1)$, avoiding the computation of
the complete image~$L(\Language_1)$. This encoding can be seen applied to automaton $B$ in
\cref{ex:string-constraints} (see \cref{fig:aut_b}).
\end{example}

\subsection{Integer Constraints on Strings}\label{sec:parikh-automata}

Parikh images are also applicable for deciding more general classes of string
constraints~\cite{ostrich-plus}. Consider the substring constraint
\cref{const:s1-substring} of \cref{ex:string-constraints}: $ s_1 =
\Substring(s_2, i, n)$, that is $s_1$ is an $n$-length substring of $s_2$
starting at offset $i$.
% (in some variants , $n$ is $i + |n|$, i.e. the ending index).
That constraint belongs to an expressive fragment of string logic that
cannot be decided by most state-of-the-art string solvers.

In \cref{sec:intuition} we modelled \cref{const:s1-substring} (and the
other constraints) using \emph{Parikh
  automata}~\cite{parikh-automata,expressiveness}. A Parikh automaton
is a finite-state automaton extended such that transitions are
additionally labelled with offset vectors defining the increments
of a finite number of counters.  This means that Parikh automata
recognise words over an extended alphabet~$\Alphabet \times D$, where
$D \subseteq \Naturals^d$ is a finite set of increment vectors
(notation as in~\cite{expressiveness}) and $\Alphabet$ is the alphabet
of the original automaton.
  
  We use the symbols~$\pi_\Alphabet, \pi_D$ to denote projections to the first
  and the second component of a composite letter~$(a, \Vector{v})$,
  respectively, and extend those projections to words:
\begin{equation*}
  \pi_\Alphabet((a_1, \Vector{v}_1) \RepeatSum{\Concat} (a_k, \Vector{v}_k))
  ~=~ a_1 \RepeatSum{\Concat} a_k,
  \qquad
  \pi_D((a_1, \Vector{v}_1) \RepeatSum{\Concat} (a_k, \Vector{v}_k))
  ~=~ \Vector{v}_1 \RepeatSum{+} \Vector{v}_k.
\end{equation*}

\begin{definition}\label{def:parikh-automata} A Parikh automaton of dimension $d
  \geq 0$ is a pair $\Tuple{\Automaton, C}$, where
  $C \subseteq \Naturals^d$ is a semi-linear set (or, equivalently, a
  Presburger formula), and $\Automaton$ is a finite automaton with the
  alphabet $\Alphabet \times D$, where $D \subseteq \Naturals^d$. We
  say that $\Tuple{\Automaton, \varphi}$ recognises a
  word~$w \in \Alphabet^*$ if and only if the automaton has a run
  accepting an extended word~$w' \in (\Alphabet \times D)^*$ such that
  $\pi_\Alphabet(w') = w$ and $\pi_D(w') \in C$.
\end{definition}

Applied to \cref{const:s1-substring}, the decision procedure in
\cite{ostrich-plus} will construct a pre-image of $s_1$ under the substring
operation, and check whether this pre-image is consistent with the constraint~$s_2 \in \Language(B)$, corresponding to the full product seen in
\cref{ex:string-constraints}. Because $\Substring$ depends on the
values of the integer variables~$i, n$, a Parikh automaton,
shown in \cref{fig:aut_a}, models the pre-image. The Parikh automaton
has dimension~$3$, as it includes also the length register~$l_{A}$, besides
variables $i, n$.  Intuitively, this construction
accumulates any prefix symbol, incrementing
$i$ to mark the start of the substring; followed by the automaton representing
the substring itself, modified to add a counter to increment $n$ at each
transition; followed by a state that accepts any
suffix after the matched substring.

% AS: I am quite unsure about which intersection we are looking for here,
% please verify I'm not wrong!
% PR: Sounds right (did some small fixes)
Denoting the language described by \cref{fig:aut_a} as $\Language_{pre}$, we can
then replace $s_1 = \Substring(s_2, i, n)$ and $s_2 \in
\Language(B)$ (of \cref{const:s1-in-c-dd}) with an
equi-satisfiable formula that no longer contains any explicit substring
operation:
%
\begin{equation}
  \label{eq:parikh-constraint}
  p \in \Language_{pre} \wedge~
  \pi_\Alphabet(p) \in \Language(B)
  \wedge~~ \pi_D(p) =
  \begin{bmatrix}
    l_{A} \\ i \\ n
  \end{bmatrix}~~
  \wedge 0 \leq i \leq i + n \leq l_{A}
\end{equation}
%
To check the satisfiability of \cref{eq:parikh-constraint}, we need a
decision procedure that can process intersections of regular languages
(in this case, of $\Language_{pre}$ and $\Language(B)$, synchronising
on $\Alphabet$), while imposing the side
condition~$0 \leq n \leq m \leq |p|$ on the increment sum. In
\cite{ostrich-plus}, this decision procedure turned out to be main
bottleneck of the string solver, which was one of the motivations to
develop the lazy algorithm proposed in this paper.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
