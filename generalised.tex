The Parikh map~$\ParikhMap$ represents a homomorphism from the (free)
non-commutative monoid~$\Strings$ to the (free) commutative
monoid~$\Naturals^k$. We are, however, often interested in projections of the
Parikh map, rather than the full image. We therefore consider \emph{arbitrary}
homomorphisms $\Map:\: \Sigma^* \to \Monoid$, where $\Monoid =
\left(X;\MonoidOp;0_{\Monoid}\right)$ is a commutative monoid. We give several
examples of such projections on Parikh images later in this section.

Observe that every homomorphism~$\Map:\: \Sigma^* \to \Monoid$ can be
represented as the composition~$h' \circ \ParikhMap$, for some
homomorphism~$h' : \Naturals^k \to M$. One of the insights underlying our
approach is that it is more efficient to directly compute a
projection on the Parikh image~$\Map(\Language)$, than to first compute the
standard image~$\ParikhMap(\Language)$ followed by projection to
some property of interest.


\begin{example}[String Length]\label{ex:length}
One such simplifying homomorphism can express string
length, the problem that originally motivated our study of the Parikh
map. This mapping is relevant when solving constraints that combine
language membership with string length, for instance the following constraint:
\begin{equation}\label{eq:stringLength}
x \in \Language_1 \wedge y \in \Language_2 \wedge |x| > |y|
\end{equation}

To solve this formula, let
$\Monoid = \Naturals$, and define the homomorphism~$L$ by $L(a) = 1$
for all characters~$a \in \Alphabet$. The length of a string
$s = s_1 \RepeatSum{\Concat} s_n$ is given by
$L(s) = \sum L(s_i) = 1 \RepeatSum{+} 1 = n$, and to solve
\eqref{eq:stringLength} we can instead solve the equi-satisfiable
formula~$\alpha \in L(\Language_1) \wedge \beta \in L(\Language_2)
\wedge \alpha > \beta$. This paper proposes efficient native
procedures to reason about membership constraints
like~$\alpha \in L(\Language_1)$, avoiding the computation of
the complete image~$L(\Language_1)$. This encoding can be seen applied to automaton $B$ in
\cref{ex:string-constraints} (see \cref{fig:aut_b}).
\end{example}

\subsection{Integer Datatype Constraints on Strings}\label{sec:parikh-automata}

Parikh images are also applicable for deciding more general classes of
string constraints~\cite{ostrich-plus}. Consider, for instance, a
constraint involving the substring operation of \cref{const:s1-substring}:
\begin{equation}\label{eq:substring}
    s_1 = \Substring(s_2, i, n)
\end{equation}

That is $s_1$ is an $n$-length substring of $s_2$ starting at offset $i$ (in
some variants , $n$ is $i + |n|$, i.e. the ending index). That constraint
belongs to an expressive fragment of string logic that cannot be decided by most
state-of-the-art string solvers.

We can model \cref{eq:substring} using the notion of a \emph{Parikh
  automaton}~\cite{parikh-automata,expressiveness}. A Parikh automaton
is a standard automaton is extended such that transitions are labelled both with characters
from the alphabet~$\Alphabet$, and with offset vectors defining the
increments of a finite number of counters. This means that Parikh
automata recognise words over an extended
alphabet~$\Alphabet \times D$, where $D \subseteq \Naturals^d$ is a
finite set of increment vectors (notation as
in~\cite{expressiveness}). We use the symbols~$\pi_\Alphabet, \pi_D$
to denote projections to the first and the second component of a
composite letter~$(a, \Vector{v})$, respectively, and extend those
projections to words:
\begin{equation*}
  \pi_\Alphabet((a_1, \Vector{v}_1) \RepeatSum{\Concat} (a_k, \Vector{v}_k))
  ~=~ a_1 \RepeatSum{\Concat} a_k,
  \qquad
  \pi_D((a_1, \Vector{v}_1) \RepeatSum{\Concat} (a_k, \Vector{v}_k))
  ~=~ \Vector{v}_1 \RepeatSum{+} \Vector{v}_k.
\end{equation*}

\begin{definition}\label{def:parikh-automata} A Parikh automaton of dimension $d
  \geq 0$ is a pair $\Tuple{\Automaton, C}$, where
  $C \subseteq \Naturals^d$ is a semi-linear set (or, equivalently, a
  Presburger formula), and $\Automaton$ is a finite automaton with the
  alphabet $\Alphabet \times D$, where $D \subseteq \Naturals^d$. We
  say that $\Tuple{\Automaton, \varphi}$ recognises a
  word~$w \in \Alphabet^*$ if and only if the automaton has a run
  accepting an extended word~$w' \in (\Alphabet \times D)^*$ such that
  $\pi_\Alphabet(w') = w$ and $\pi_D(w') \in C$.
\end{definition}


    Applied to \eqref{eq:substring}, the decision procedure in
\cite{ostrich-plus} will construct a pre-image of $\Language_2$ under
the substring operation~$\cdot[n:m]$, and check whether this pre-image
is consistent with the constraint~$x \in \Language_1$. Because the
substring operation depends on the values of the integer
variables~$n, m$, a Parikh automaton of dimension~$2$ is a suitable
formalism to describe the pre-image, resulting
in the automaton in Fig.~\ref{fig:parikh-automata} (right). The first
component of the increment vectors is used to count the number of
letters eliminated in the beginning of the string (value~$n$), while
the second component records the beginning of the eliminated suffix
(value~$m$).

Denoting the language described by Fig.~\ref{fig:parikh-automata}
(right) as $\Language_{pre}$, we can then replace \eqref{eq:substring}
with an equi-satisfiable formula that no longer contains any explicit
substring operation:
%
\begin{equation}
  \label{eq:parikh-constraint}
  p \in \Language_{pre} \wedge~
  \pi_\Alphabet(p) \in \Language_1
  \wedge~~ \pi_D(p) =
  \begin{bmatrix}
    n \\ m
  \end{bmatrix}~~
  \wedge 0 \leq n \leq m \leq |p|
\end{equation}
%
To check the satisfiability of \eqref{eq:parikh-constraint}, we need a
decision procedure that can process intersections of regular languages
(in this case, of $\Language_{pre}$ and $\Language_1$, synchronising
on $\Alphabet$), while imposing the side
condition~$0 \leq n \leq m \leq |p|$ on the increment sum. In
\cite{ostrich-plus}, this decision procedure turned out to be main
bottleneck of the string solver, which was one of the motivations to
develop the lazy algorithm proposed in this paper.

\iffalse
\begin{figure}[t]
  \centering
      \includegraphics[width=0.5\linewidth]{parikh_automaton}
      \caption{The automaton part of a Parikh automaton for $\AcaOrBc{}$ with
      $\Alphabet = \Set{\text{a, b, c}}, d = 3$. The semilinear set/Presburger
      formula containing the constraints on the final register values cannot be
      visualised.}\label{fig:parikh-automaton}
    \end{figure}
\fi