counter int l_A, l_B, i, n;

synchronised {
automaton a_prime {
  init I_A;

  I_A -> I_A [any] { l_A += 1, i += 1};


  I_A -> D [#d] { l_A += 1, n += 1};
  I_A -> F_A [#c] { l_A += 1, n += 1};

  D -> F_A [#d] { l_A += 1, n += 1};

  F_A-> F_A  [any] { l_A += 1};

  accepting F_A;
};

automaton B {
    init I_B;
    accepting F_B;

    I_B -> A [#a] { l_B += 1 };
    I_B -> B [#b] { l_B += 1 };

    A -> A [#c] { l_B += 1 };
    A -> F_B [#a] { l_B += 1 };

    B -> I_B [#b] { l_B += 1 };
    B -> B [#c] { l_B += 1 };
    B -> F_B [#c] { l_B += 1 };
};
};

// This is implied
constraint l_A = l_B;

// Weird constraint to make it non-trivially unsatisifiable.
constraint n > i;

// These just prune the search space to keep the example short!

// Something after
constraint l_B - i - n > 0;

// Something before
constraint i > 0;