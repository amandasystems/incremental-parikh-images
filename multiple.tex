
We now generalise our calculus to natively work with intersections of
regular languages, or equivalently products of automata. For this
extension, we change the main predicate~$\Image$ to be indexed by a
vector of automata~$\Tuple{\Automaton_1, \ldots, \Automaton_k}$.  For
simplicity, we assume that the sets of states of the $k$ automata (and
therefore also the transition sets) are pairwise disjoint. 
\begin{definition}\label{def:multiple}
  Suppose $\Automaton_1, \ldots, \Automaton_k$ are automata,
  $\Map : \Alphabet^* \to \Monoid$ is a map to a commutative monoid
  $\Monoid$,
  $\Filter: \bigcup_{i=1}^k \Transitions_{\Automaton_i} \to \Naturals$
  is a transition selection function, and
  $\MonoidElement \in \Monoid$. The predicate
  $\ImagePredicate{\Tuple{\Automaton_1, \ldots,
      \Automaton_k}}{\Map}{\Filter}{\MonoidElement}$ is true exactly
  when there are accepting paths~$\Path_1, \ldots, \Path_k$ of the
  respective automata, such that for each $i \in \{1, \ldots, k\}$ and
  $\Transition \in \Transitions_{\Automaton_i}$ it holds that
  \begin{itemize}
  \item the multiplicity of $\Transition$ on $\Path_i$ is consistent with
    $\Filter$, that is,
    $\Filter(\Transition) = \TransitionCount(\Transition, \Path_i)$,
  \item the automata all accept the same
    word~$\WordOf(\Path_i) = \WordOf(\Path_1)$, and
  \item the accepted word is mapped to
    $\MonoidElement = \Map(\WordOf(\Path_i)) =
    \Map(\WordOf(\Path_1))$.
  \end{itemize}
\end{definition}

  \begin{table}[t]
    \caption{Additional derivation rules for products of arbitrarily many automata.}\label{tbl:rules:multi}
    \begin{tabular}{@{}l>{$}c<{$}p{3cm}@{}}\toprule
      Name & \text{Rule} & Side conditions\\
      \midrule
    
      % EXPAND
      \ExpandM{} & 
      \inferrule%
      {
       {\begin{array}{c@{}}
           \left\{
            \begin{array}{l@{}}
              \FlowEq(\Automaton_i, \Filter),\\
              \Connected(\Automaton_i, \Filter),\\
              \MonoidElement = \sum_{\Transition \in \Transitions_{\Automaton_i}} \Filter(\Transition) \cdot \Map(\Transition)
            \end{array}
            \right\}_{i=1}^k,
           \\[4ex]
          \ImagePredicate{\Tuple{\Automaton_1, \ldots, \Automaton_k}}{\Map}{\Filter}{\MonoidElement}, ~
          \SomeInequalities, \SomeClause
        \end{array}}
        }
      {\ImagePredicate{\Tuple{\Automaton_1, \ldots, \Automaton_k}}{\Map}{\Filter}{\MonoidElement}, \SomeInequalities, \SomeClause} & 
      None \\[5ex]
      \Materialise{} &
      \inferrule%
      {{
         \begin{array}{l@{}}
           \FlowEq(\Automaton', \Filter'),\\
           \Connected(\Automaton', \Filter'),\\
           \BindingSum(\Automaton_i, \Automaton_j, \Automaton', \Filter')\\
           \ImagePredicate{
                     \Tuple{%
                     \begin{array}{l@{}l@{}l@{}}
                      \Automaton_1, & \Automaton_{i-1}, & \Automaton_{i+1}, \\
                      \ldots, & \Automaton_{j-1}, & \Automaton_{j+1}, \\
                      \ldots, & \Automaton_k, & \Automaton'
                     \end{array}
                     }
           }{\Map}{\Filter'}{\MonoidElement},\\
\SomeInequalities, \SomeClause
           \end{array}}
           }
      {{
      \begin{array}{l@{}}
      \ImagePredicate{
        \Tuple{%
        \begin{array}{l@{}l@{}}%
          \Automaton_1,  \ldots, & \Automaton_i, \ldots, \\
          \Automaton_j, \ldots, & \Automaton_k
        \end{array}%
        }}{\Map}{\Filter}{\MonoidElement}
        \SomeInequalities, \SomeClause{}
      \end{array}}} &%
      $\begin{array}{l@{}}
          \Filter' = \Extend(\Automaton',\Filter),\\
          1 \leq i < j \leq k, \\
       \Automaton' =
         \Filter_{\SomeInequalities}(\Automaton_i) \times \Filter_{\SomeInequalities}(\Automaton_j)\\
      \end{array}$ \\
      \bottomrule
      \end{tabular}
    \end{table}

    For the calculus (\cref{tbl:rules:multi}), we first extend
    $\Expand$ to generate flow equations and instances of $\Connected$
    for each automaton, resulting in a new rule $\ExpandM$.  Unlike
    \Expand{}, \ExpandM{} does not remove the $\Image$~predicate,
    since it is needed to keep track of the currently considered
    partial products.


The rule~$\Materialise$ introduces the product of two individual
automata~$\Automaton_i, \Automaton_j$; this step eliminates
$\Automaton_i, \Automaton_j$ as index of the $\Image$ predicate, and
instead adds the product of the automata restricted to the
transitions that can still be taken. The rule
also introduces the flow equations and the $\Connected$ predicate.

In $\Materialise$, we use the following notation for pruning away
parts of an automaton based on the transition selection
function~$\sigma$, only keeping those transitions for which~$\Filter$
is positive:
\begin{equation*}
  \Filter_{\SomeInequalities}(\Automaton) =
  \Tuple{\States, \InitialState, \AcceptingStates,
\Set{\Transition \in \Transitions \SuchThat (\Filter(\Transition) = 0) \not\in E}}
\end{equation*}
This filtering operation can be optimised to also eliminate states from
$Q$ and $F$ that become unreachable; this is kept implicit for sake of
presentation at this point.

The rule~$\Materialise$ has to connect the newly introduced
product to the previous automata
$\Automaton_i, \Automaton_j$. This is done by extending the
selection function~$\Filter$ to $\Filter'$, mapping the transitions of the product
to fresh variables~$x_{\Transition}$:
\begin{equation*}
  \Extend(\Automaton',\sigma)(t)
  ~~=~~
  \begin{cases}
    x_{\Transition} & t \in \Transitions_{\Automaton'}
    \\
    \Filter(t) & \text{otherwise}
  \end{cases}
\end{equation*}

The multiplicity of transitions in the product then has to be related
to the multiplicities in the individual automata, modelled using the
$\BindingSum$ predicate. The predicate expresses that the multiplicity
of a transition~$\Transition \in \Transitions_{\Automaton_i}$ in
$\Automaton_i$ has to coincide with the sum of the multiplicities of
transitions in $\Filter_{\SomeInequalities}(\Automaton_i) \times \Filter_{\SomeInequalities}(\Automaton_j)$ derived from $t$,
and similarly for $\Automaton_j$:
%
  $$
  \BindingSum(\Automaton_i, \Automaton_j, \Automaton', \Filter') ~~=~~
  \begin{aligned}
  & \Set{ 
    \Filter'(\Transition)  =  \sum\limits_{\Transition' = \FromLabelTo{\Tuple{\State, \State_R}}{\Label}{\Tuple{\State', \State'_R}} \in \Transitions_{\Automaton'}} \Filter'(\Transition')
  \SuchThat \Transition = \FromLabelTo{\State}{\Label}{\State'} \in \Transitions_{\Automaton_i} } \cup\mbox{} \\ 
  & \Set{
    \Filter'(\Transition)  =  \sum\limits_{\Transition' = \FromLabelTo{\Tuple{\State_L, \State}}{\Label}{\Tuple{\State'_L, \State'}} \in \Transitions_{\Automaton'}} \Filter'(\Transition') \SuchThat \Transition = \FromLabelTo{\State}{\Label}{\State'} \in \Transitions_{\Automaton_j}
  }
  \end{aligned}
$$

For instances of precisely one automaton, neither rule applies, and we perform
the calculus as before.

\subsection{An Example}\label{sec:multiple:example}


\begin{figure}
  \centering
\begin{prooftree}
  {% % LEFT TREE: here x_12 is zero
  \hypo{
    \begin{array}{l}
      \ldots \boxed{\land 1 = 0} \\
      \land \Image{}_{\emptyset, \Map}(\Filter, \VectorLiteral{l_A, 1, 2, l_A})
    \end{array}
  }
  \infer1[\Materialise]{
    \begin{array}{llll}
      \TransitionVar_9 = 0 
      \land \TransitionVar_7 = l_A - 2 \\
      \land \TransitionVar_2 = l_A - 3
      \land \TransitionVar_{8} = 0 \\
      \land \TransitionVar_6 = \TransitionVar_{11} = 1
      \land \TransitionVar_{10} = 0 \\
      \land \Connected(B, \Filter)\\
      \land \Image{}_{\Tuple{\mathcal{A}',\mathcal{B}}, \Map}(\Filter, \VectorLiteral{l_A, 1, 2, l_A})
    \end{array}
  }
  \infer1[\Propagate{}]{
    \begin{array}{llll}
      \TransitionVar_{12} = 0 
      \land \TransitionVar_7 = l_A - \TransitionVar_9 - 2 \\
      \land \TransitionVar_2 = l_A - 3 
      \land \TransitionVar_{8} = 0 \\
      \land \TransitionVar_6 = \TransitionVar_{11} = 1 \\
      \land \TransitionVar_{10} = 0 
      \land \Connected(\mathcal{B}, \Filter) \\
      \land \Image{}_{\Tuple{\mathcal{A}',\mathcal{B}}, \Map}(\Filter, \VectorLiteral{l_A, 1, 2, l_A}) 
    \end{array}
    }
  }% END LEFT TREE
  {% RIGHT TREE % here x_12 is > 0
  \hypo{
    \begin{array}{l}
      \ldots \boxed{\land 1 = 0} \\
      \land \Image{}_{\emptyset, \Map}(\Filter, \VectorLiteral{l_A, 1, 2, l_A})
    \end{array}
  }
  \infer1[\Materialise]{
    \begin{array}{rrrr}
      \TransitionVar_{12} > 0 \land \\
      \TransitionVar_7 = l_A - \TransitionVar_9 - 2\TransitionVar_{11}-2\TransitionVar_{12} \land \\
      \TransitionVar_2 = l_A - 3 \land \\
      \TransitionVar_{8} = \TransitionVar_{11} + \TransitionVar_{12} - 1 \land \\
      \TransitionVar_6 = \TransitionVar_{11} \land\\
      \TransitionVar_{10} = 1 - \TransitionVar_{11} \land\\
      \Connected(\mathcal{B}, \Filter) \land\\
      \Image{}_{\Tuple{\mathcal{A}',\mathcal{B}}, \Map}(\Filter, \VectorLiteral{l_A, 1, 2, l_A}) 
    \end{array}
  }
  }% END RIGHT TREE
  \infer2[\Split{} $\TransitionVar_{12} = 0$]{
  \begin{array}{llll}
    \TransitionVar_7 = l_A - \TransitionVar_9 - 2\TransitionVar_{11}-2\TransitionVar_{12} \\
    \land \TransitionVar_2 = l_A - 3 \\
    \land \TransitionVar_{8} = \TransitionVar_{11} + \TransitionVar_{12} - 1 \\
    \land \TransitionVar_6 = \TransitionVar_{11} \\
    \land \TransitionVar_{10} = 1 - \TransitionVar_{11} \\
    \land \Connected(\mathcal{B}, \Filter)\\
    \land \Image{}_{\Tuple{\mathcal{A}',\mathcal{B}}, \Map}(\Filter, \VectorLiteral{l_A, 1, 2, l_A}) 
  \end{array}
  }
  \infer1[Expand $\sum$, \EquationReasoning] {
    \begin{array}{llll}
      l_A = \sum_{k = 6}^{k = 12} \TransitionVar_k
      \land \TransitionVar_2 = l_A - 3
      \land 1 + \TransitionVar_{8}   = \TransitionVar_{11} + \TransitionVar_{12}
      \land \TransitionVar_{11} = \TransitionVar_6 \\
      \land \TransitionVar_{12} = \TransitionVar_8 + \TransitionVar_{10}
      \land \Connected(\mathcal{B}, \Filter) 
      \land \Image{}_{\Tuple{\mathcal{A}',\mathcal{B}}, \Map}(\Filter, \VectorLiteral{l_A, 1, 2, l_A}) 
    \end{array}
  }
  \infer1[\EquationReasoning: expand $\FlowEq$]{
    \begin{array}{llll}
      l_A = \sum_{k = 6}^{k = 12} \TransitionVar_k
      \land \TransitionVar_2 = l_A - 3
      \land \FlowEq(\mathcal{B}, \Filter) \\
      \land \Connected(\mathcal{B}, \Filter) 
      \land \Image{}_{\Tuple{\mathcal{A}',\mathcal{B}}, \Map}(\Filter, \VectorLiteral{l_A, 1, 2, l_A}) 
    \end{array}
  }
  \infer1[Repeat \cref{fig:derivation:single}, $l_A = l_B$.]{
    \begin{array}{llll}
      l_B = \sum_{k = 6}^{k = 12} \TransitionVar_k
      \land i = \TransitionVar_5
      \land l_A = \sum_{k = 1}^{k = 5} \TransitionVar_k \\
      \land n = \TransitionVar_4 + \TransitionVar_1
      \land \FlowEq(\mathcal{B}, \Filter)
      \land \Connected(\mathcal{A}', \Filter)\\
      \land \Connected(\mathcal{B}, \Filter)
      \land \Image{}_{\Tuple{\mathcal{A}',\mathcal{B}}, \Map}(\Filter, \VectorLiteral{l_A, i, n, l_B}) \\
      \land l_A = l_B
      \land l_A - i - n > 0
      \land 0 < i < n
    \end{array}
  }
  \infer1[\ExpandM]{
    \Image{}_{\Tuple{\mathcal{A}',\mathcal{B}}, \Map}(\Filter, \VectorLiteral{l_A, i, n, l_B})
    \land l_A = l_B % Implied constraint
    \land l_A - i - n > 0
    \land 0 < i < n
    }
\end{prooftree}
\caption{A derivation for \Calculus{} on the Parikh image strings for the
constraints of \cref{ex:string-constraints}. Note the constant propagation
for~$n$!}\label{fig:derivation:multi}
\Description[]{}% This isn't a problem; it's all text
\end{figure}

We return to our example in \cref{sec:intuition}. We also reuse the
definition of $\Map$ as the simple projection to extract the counter increments,
so in this case, $\Map(\Transition) = \left[l_{B+}\right]$ for every
transition~$\Transition$ since $\mathcal{B}$ only counts length. The reader is
advised to review \cref{fig:aut_a_annotated,fig:aut_b_annotated} from
\cref{sec:intuition} while going through this example.
The transition variables of the figures match the ones used here.

We extend \cref{eq:single-filter} from \cref{sec:single:example} with
definitions for $B$ shown in \cref{eq:multi-filter}:
\begin{equation}\label{eq:multi-filter}
  \begin{array}{rl@{\qquad}rl@{\qquad}rl}
     \Filter(\FromLabelTo{A}{a / l_{B+}}{F_B} ) &= \TransitionVar_6 
     &
     \Filter(\FromLabelTo{A}{c / l_{B+}}{A} ) &= \TransitionVar_7 
     &
      \Filter(\FromLabelTo{B}{b / l_{B+}}{I_B}) &= \TransitionVar_8 
     \\
     \Filter(\FromLabelTo{B}{c / l_{B+}}{B}) &= \TransitionVar_9 
     &
     \Filter(\FromLabelTo{B}{c / l_{B+}}{F_B}) &= \TransitionVar_{10}
     &
     \Filter(\FromLabelTo{I_B}{a / l_{B+}}{A}) &= \TransitionVar_{11}
     \\
      \Filter(\FromLabelTo{I_B}{b / l_{B+}}{B}) &= \TransitionVar_{12}
    \\[3ex]
% 
    \multicolumn{6}{c}{
        \FlowEq(\mathcal{B}, \Filter) =\quad  \begin{aligned}
            1 + \TransitionVar_{8}   &= \TransitionVar_{11} + \TransitionVar_{12} \wedge\mbox{}\\
            \TransitionVar_{11} &= \TransitionVar_6\wedge\mbox{}\\
            \TransitionVar_{12} &= \TransitionVar_8 + \TransitionVar_{10}\mbox{}\\
            \TransitionVar_6 + \TransitionVar_{10} &= 1
        \end{aligned}}
  \end{array}
\end{equation}

The only possible rule at the start is $\ExpandM$, which we use to add the
corresponding constraints on each automaton of the product as we would have had
in the single-automaton version. After that, we expand the various sums and apply
light equality propagation.

We then continue by repeating the steps of~\cref{sec:single:example}, shown 
in~\cref{fig:derivation:single} since the steps to propagate
\cref{ex:string-constraints} across the automaton $\mathcal{A}'$ still apply for the
product. Note that this fixes the values of all transitions but one of $\mathcal{A}'$ as
constants, including the free counter variables $i, n$, whose new constant
values we propagate everywhere.

Once we have performed reasoning by equality to eliminate transition variables,
we obtain the version of $\mathcal{B}$ shown in \cref{fig:aut_b_annotated} and represented
by the clauses in the final node in the tree. This corresponds to the end of
\cref{sec:intuition:algebra}. Our only options now are to either split on which
path we take from $I_B$ by case-splitting on~$\TransitionVar_{12}$ or to
directly invoke \Materialise{}. The latter would produce a shorter tree in this
instance but might lead to a larger product being computed, so we (and indeed
\Catra{}) pick \Split{}. This leads to an opportunity for propagation since
$\TransitionVar_{12} = 0$ cuts off $\TransitionVar_{9}$ from $I_B$ on the left
branch. Note that the same opportunity does not present itself on the right
branch, though; the use of the upper path to state~$A$ does not preclude visiting
state~$B$.

In both cases, we have comparatively simple automata left, so we apply
\Materialise{} to obtain their product, which for both branches is empty. An
empty product will have no outgoing transitions from its initial state, and so
will produce a flow equation $1 = 0$ since the right-hand balancing side will
always be the empty sum. We can then close the proof and know that the problem
is unsatisfiable. A full derivation tree for the example can be found 
in~\cref{fig:derivation:multi}.


\subsection{Correctness of \Calculus{} for Products of Automata}

Since \cref{tbl:rules:multi} only extends the existing rules of
\cref{tbl:rules:single}, we focus on the differences compared
to the calculus for a single automaton.

\subsubsection{\Calculus{} for Products of Automata Terminates}
\begin{lemma}\label{lma:multi-terminates}
  Suppose $\SomeClause{}$ is a set of formulas in which the product
  version of $\Image$ only occurs positively. There is no
  infinite sequence of proofs~$P_0, P_1, P_2, \ldots$ in which $P_0$
  has $\SomeClause{}$ as root, and each $P_{i+1}$ is derived from
  $P_i$ by applying one of the rules in \cref{tbl:rules:multi}.
\end{lemma}

\begin{proof}
  The rule \Materialise{} can similarly only be used finitely many times, as
  each application reduces the number of automata in the product of $\Image$ by
  one automaton, until only one remains and \cref{lma:single-terminates} for
  single-automaton instances apply.
  
  \ExpandM{} can only be applied precisely once per $\Image$~term since
  each application introduces an identical set of formulas and we have a generic
  side condition that no rule may add only redundant formulas.
\end{proof}

\subsubsection{The Rules in \cref{tbl:rules:multi} are Solution-preserving}

Since our calculus now includes a rule introducing new variables, the
\Materialise{} rule, we have to slightly generalise the notion of
solution-preservation:
%
\begin{lemma}\label{lma:multi-correct}
  Consider an application of one of the rules in
  \cref{tbl:rules:multi}, with
  premises~$\SomeClause_1, \ldots, \SomeClause_k$ and
  conclusion~$\SomeClause$. An assignment~$\beta$ (over the symbols in
  $\SomeClause$) satisfies the conclusion~$\SomeClause$ if and only if
  there is an extension~$\beta' of \beta$ satisfying one of the
  premises~$\SomeClause_i$.
\end{lemma}

\begin{proof}
  We have to consider the two new rules in \cref{tbl:rules:multi}. The
  result is immediate for \ExpandM{}, since this rule does not remove the
  $\Image$ predicate from a proof goal, and the newly introduced formulas
  are all implied by the $\Image$ predicate.

  For \Materialise{}, observe that the existence of an accepting path
  in $\Automaton_i \times \Automaton_j$ is equivalent to the existence
  of individual paths in $\Automaton_i, \Automaton_j$ accepting the
  same word. The path in the product will satisfy the flow equations
  and connectedness, and it will be related to the individual paths as
  stipulated by the \BindingSum{} predicate.
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
