
We now generalise our calculus to natively work with intersections of
regular languages, or equivalently products of automata. For this
extension, we change the main predicate~$\Image$ to be indexed by a
vector of automata~$\Tuple{\Automaton_1, \ldots, \Automaton_k}$.  For
simplicity, we assume that the sets of states of the $k$ automata (and
therefore also the transition sets) are pairwise disjoint. 
\begin{definition}\label{def:multiple}
  Suppose $\Automaton_1, \ldots, \Automaton_k$ are automata,
  $\Map : \Alphabet^* \to \Monoid$ is a map to a commutative monoid
  $\Monoid$,
  $\Filter: \bigcup_{i=1}^k \Transitions_{\Automaton_i} \to \Naturals$
  is a transition selection function, and
  $\MonoidElement \in \Monoid$. The predicate
  $\ImagePredicate{\Tuple{\Automaton_1, \ldots,
      \Automaton_k}}{\Map}{\Filter}{\MonoidElement}$ is true exactly
  when there are accepting paths~$\Path_1, \ldots, \Path_k$ of the
  respective automata, such that for each $i \in \{1, \ldots, k\}$ and
  $\Transition \in \Transitions_{\Automaton_i}$ it holds that
  \begin{itemize}
  \item the multiplicity of $\Transition$ on $\Path_i$ is consistent with
    $\Filter$, that is,
    $\Filter(\Transition) = \TransitionCount(\Transition, \Path_i)$,
  \item the automata all accept the same
    word~$\WordOf(\Path_i) = \WordOf(\Path_1)$, and
  \item the accepted word is mapped to
    $\MonoidElement = \Map(\WordOf(\Path_i)) =
    \Map(\WordOf(\Path_1))$.
  \end{itemize}
\end{definition}

  \begin{table}[t]
    \begin{tabular}{@{}l>{$}c<{$}p{3cm}@{}}\toprule
      Name & \text{Rule} & Side conditions\\
      \midrule
    
      % EXPAND
      \ExpandM & 
      \inferrule
      {
       {\begin{array}{c}
           \left\{
           \FlowEq(\Automaton_i, \Filter),~~
           \Connected(\Automaton_i, \Filter),~~
           \MonoidElement = \sum_{\Transition \in \Transitions_{\Automaton_i}} \Filter(\Transition) \cdot \Map(\Transition)
           \right\}_{i=1}^k,
           \\[4ex]
          \ImagePredicate{\Tuple{\Automaton_1, \ldots, \Automaton_k}}{\Map}{\Filter}{\MonoidElement}, ~
          \SomeInequalities, \SomeClause
        \end{array}}
        }
      {\ImagePredicate{\Tuple{\Automaton_1, \ldots, \Automaton_k}}{\Map}{\Filter}{\MonoidElement}, \SomeInequalities, \SomeClause} & 
      None \\[5ex]
      \Materialise &
      \inferrule
      {{
         \begin{array}{c}
           \FlowEq(\Automaton', \Filter'),~
           \Connected(\Automaton', \Filter'),~
           \BindingSum(\Automaton_i, \Automaton_j, \Filter')
           \\\ImagePredicate{
                     \Tuple{\Automaton_1, \Automaton_{i-1}, \Automaton_{i+1}, \ldots,
                     \Automaton_{j-1}, \Automaton_{j+1}, \ldots, \Automaton_k,
                     \Automaton'},~ \SomeInequalities, \SomeClause
           }{\Map}{\Filter'}{\MonoidElement}
           \end{array}}
           }
      {\ImagePredicate{\Tuple{\Automaton_1, \ldots, \Automaton_i, \ldots, \Automaton_j, \ldots, \Automaton_k}}{\Map}{\Filter}{\MonoidElement},~ \SomeInequalities, \SomeClause} &
      $\begin{array}{@{}l@{}}
         \Filter' = \Extend(\Automaton_i, \Automaton_j,\Filter),\\
         1 \leq i < j \leq k, \\
      \Automaton' = \Automaton_i \times \Automaton_j,\\
      \end{array}$ \\
      \bottomrule
      \end{tabular}
      \caption{Additional derivation rules for products of arbitrarily many automata.}\label{tbl:rules:multi}
    \end{table}

    For the calculus (\cref{tbl:rules:multi}), we first extend
    $\Expand$ to generate flow equations and instances of $\Connected$
    for each automaton, resulting in a new rule $\ExpandM$.  Unlike
    \Expand{}, \ExpandM{} does not remove the $\Image$~predicate,
    since it is needed to keep track of the currently considered
    partial products.

The rule~$\Materialise$ introduces the product of two individual
automata~$\Automaton_i, \Automaton_j$; this step eliminates
$\Automaton_i, \Automaton_j$ as index of the $\Image$ predicate, and
instead adds the product~$\Automaton_i \times \Automaton_j$, while
also introducing the flow equations and the $\Connected$ predicate.

The rule~$\Materialise$ also has to connect the newly introduced
product~$\Automaton_i \times \Automaton_j$ to the previous automata
$\Automaton_i, \Automaton_j$. This is done by extending the
selection function~$\Filter$ to $\Filter'$, mapping the transitions of the product
to fresh variables~$x_{\Transition}$:
\begin{equation*}
  \Extend(\Automaton_i, \Automaton_j,\sigma)(t)
  ~~=~~
  \begin{cases}
    x_{\Transition} & t \in \Transitions_{\Automaton_i \times \Automaton_j}
    \\
    \Filter(t) & \text{otherwise}
  \end{cases}
\end{equation*}

The multiplicity of transitions in the product then has to be related
to the multiplicities in the individual automata, modelled using the
$\BindingSum$ predicate. The predicate expresses that the multiplicity
of a transition~$\Transition \in \Transitions_{\Automaton_i}$ in
$\Automaton_i$ has to coincide with the sum of the multiplicities of
transitions in $\Automaton_i \times \Automaton_j$ derived from $t$,
and similarly for $\Automaton_j$:
%
  $$
  \BindingSum(\Automaton_i, \Automaton_j, \Filter') ~~=~~
  \begin{aligned}
  & \Set{ 
    \Filter'(\Transition)  =  \sum\limits_{\Transition' = \FromLabelTo{\Tuple{\State, \State_R}}{\Label}{\Tuple{\State', \State_R}}} \Filter'(\Transition')
  \SuchThat \Transition = \FromLabelTo{\State}{\Label}{\State'} \in \Transitions_{\Automaton_i} } \cup\mbox{} \\ 
  & \Set{
    \Filter'(\Transition)  =  \sum\limits_{\Transition' = \FromLabelTo{\Tuple{\State_L, \State}}{\Label}{\Tuple{\State_L, \State'}}} \Filter'(\Transition') \SuchThat \Transition = \FromLabelTo{\State}{\Label}{\State'} \in \Transitions_{\Automaton_j}
  }
  \end{aligned}
$$

\iffalse
Note that this definition implies that $\Filter(\Transition) =
\Filter(\Transition')$ whenever two transitions $\Transition \in
\Transitions_{\Automaton_1}, \Transition' \in \Transitions_{\Automaton_2}$
produces a product transition $\Transition'' \in \Transitions_{\Automaton_1
\times \Automaton_2}$. This corresponds to our intuition that the terms of the
product must agree on the value they accept. As before, we implicitly map
$\Filter$ to fresh terms for each transition in the product.
\fi

For instances of precisely one automaton, neither rule applies and we
perform the calculus as before.

\subsection{An Example}\label{sec:multiple:example}

We return again to our example in \cref{sec:intuition}.We also reuse the
definition of $\Map$ as the simple projection to extract the counter increments,
so in this case, $\Map(\Transition) = \left[l_{B+}\right]$ for every
transition~$\Transition$ since we are only counting the length. The reader is
strongly advised to review \cref{fig:aut_a_annotated,fig:aut_b_annotated} from
\cref{sec:intuition} while going through this example! In particular, note that
the transition variables of the figures correspond to the ones used here.

The transition variables of \cref{sec:single:example} recur
\cref{eq:single-filter}, but we add the definitions for $B$ shown in
\cref{eq:multi-filter}:
\begin{equation}\label{eq:multi-filter}
    \begin{aligned}
        \Filter(\FromLabelTo{A}{a / l_{B+}}{F_B} ) = \TransitionVar_6\\
        \Filter(\FromLabelTo{A}{c / l_{B+}}{A} ) = \TransitionVar_7\\
        \Filter(\FromLabelTo{B}{b / l_{B+}}{I_B})= \TransitionVar_8 \\
        \Filter(\FromLabelTo{B}{c / l_{B+}}{B})= \TransitionVar_9\\
        \Filter(\FromLabelTo{B}{c / l_{B+}}{F_B})= \TransitionVar_{10}\\
        \Filter(\FromLabelTo{I_B}{a / l_{B+}}{A})= \TransitionVar_{11}\\
        \Filter(\FromLabelTo{I_B}{b / l_{B+}}{B})= \TransitionVar_{12}\\
        \FlowEq(B, \Filter) =  \begin{aligned}
            1 + \TransitionVar_{8}   &= \TransitionVar_{11} + \TransitionVar_{12}\\
            \land \TransitionVar_{11} &= \TransitionVar_6\\
            \land \TransitionVar_{12} &= \TransitionVar_8 + \TransitionVar_{10}
        \end{aligned}
    \end{aligned}
\end{equation}


The only possible rule at the start is $\ExpandM$, which we use to add the
corresponding constraints on each automata of the product as we would have had
in the single-automaton version. 

We then continue by repeating the steps of the steps of
\cref{sec:single:example} shown in \cref{fig:derivation:single}, since the steps
to propagate \cref{ex:string-constraints} across the automaton $A'$ still apply
for the product. Note that this fixes the values of all transitions but one as
constants.

\Fudge{description here!}

\begin{figure}
  \centering
\begin{prooftree}
  {% % LEFT TREE: here x_12 is zero
  \hypo{PROOF CLOSED}
  \infer1[\Propagate]{WHAT HAPPENS WHEN X_12 IS ZERO}
  }% END LEFT TREE
  {% RIGHT TREE % here x_12 is one
  \hypo{r} 
  }% END RIGHT TREE
  \infer2[\Split{} $\TransitionVar_{12} = 0$]{
  \begin{aligned}
    \TransitionVar_7 = l_A - \TransitionVar_9 - 2\TransitionVar_{11}-2\TransitionVar_{12}\\
    \land \TransitionVar_2 = l_A - 3\\
    \land \TransitionVar_{8} = \TransitionVar_{11} + \TransitionVar_{12} - 1\\
    \land \TransitionVar_6 = \TransitionVar_{11}\\
    \land \TransitionVar_{10} = 1 - \TransitionVar_{11}\\
    \land \Connected(B, \Filter) \\
    \land \Image{}_{\Tuple{A',B}, \Map}(\Filter, \VectorLiteral{l_A, 1, 2, l_A}) 
  \end{aligned}
  }
  \infer1[Expand $\sum$, \EquationReasoning] {
    \begin{aligned}
      l_A = \sum_{k = 6}^{k = 12} \TransitionVar_k\\
      \land \TransitionVar_2 = l_A - 3\\
      \land 1 + \TransitionVar_{8}   = \TransitionVar_{11} + \TransitionVar_{12}\\
      \land \TransitionVar_{11} = \TransitionVar_6\\
      \land \TransitionVar_{12} = \TransitionVar_8 + \TransitionVar_{10}\\
      \land \Connected(B, \Filter) \\
      \land \Image{}_{\Tuple{A',B}, \Map}(\Filter, \VectorLiteral{l_A, 1, 2, l_A}) 
    \end{aligned}
  }
  \infer1[\EquationReasoning: expand $\FlowEq$]{
    \begin{aligned}
      l_A = \sum_{k = 6}^{k = 12} \TransitionVar_k\\
      \land \TransitionVar_2 = l_A - 3\\
      \land \FlowEq(B, \Filter) \\
      \land \Connected(B, \Filter) \\
      \land \Image{}_{\Tuple{A',B}, \Map}(\Filter, \VectorLiteral{l_A, 1, 2, l_A}) 
    \end{aligned}
  }
  \infer1[Repeat \cref{fig:derivation:single}, $l_A = l_B$.]{
    \begin{aligned}
      l_B = \sum_{k = 6}^{k = 12} \TransitionVar_k\\
      \land i = \TransitionVar_5\\
      \land l_A = \sum_{k = 1}^{k = 5} \TransitionVar_k\\
      \land n = \TransitionVar_4 + \TransitionVar_1\\  
      \land \FlowEq(B, \Filter) \\
      \land \Connected(A', \Filter) \\
      \land \Connected(B, \Filter) \\
      \land \Image{}_{\Tuple{A',B}, \Map}(\Filter, \VectorLiteral{l_A, i, n, l_B}) 
      \land l_A = l_B\\
      \land l_A - i - n > 0\\
      \land 0 < i < n
    \end{aligned}
  }
  \infer1[\ExpandM]{
    \Image{}_{\Tuple{A', B}, \Map}(\Filter, \VectorLiteral{l_A, i, n, l_B})
    \land l_A = l_B % Implied constraint
    \land l_A - i - n > 0
    \land 0 < i < n
    }
\end{prooftree}
\caption{A derivation for \Calculus{} on the Parikh image strings for the
constraints of \cref{ex:string-constraints}. Note the constant propagation
for~$n$!}\label{fig:derivation:multi}
\end{figure}

\subsection{Correctness of \Calculus{} for Products of Automata}

Since \cref{tbl:rules:multi} only extends the existing rules of
\cref{tbl:rules:single}, we focus on the differences compared
to the calculus for a single automaton.

%\subsubsection{\Calculus{} for products of automata terminates}
\begin{lemma}\label{lma:multi-terminates}
  Suppose $\SomeClause{}$ is a set of formulas in which the product
  version of $\Image$ only occurs positively. There is no
  infinite sequence of proofs~$P_0, P_1, P_2, \ldots$ in which $P_0$
  has $\SomeClause{}$ as root, and each $P_{i+1}$ is derived from
  $P_i$ by applying one of the rules in \cref{tbl:rules:multi}.
\end{lemma}

\begin{proof}
  The rule \Materialise{} can similarly only be used finitely many times, as
  each application reduces the number of automata in the product of $\Image$ by
  one automaton, until only one remains and \cref{lma:single-terminates} for
  single-automaton instances applies.
  
  This implies that also the rule~\ExpandM{} can only be applied
  finitely often since its side condition only allows applying it once
  per instance of an $\Image$ predicate containing a product, and only finitely
  many instances of $\Image$ can be introduced on each branch.
\end{proof}

%\subsubsection{The rules in \cref{tbl:rules:multi} are solution-preserving}

Since our calculus now includes a rule introducing new variables, the
\Materialise{} rule, we have to slightly generalise the notion of
solution-preservation:
%
\begin{lemma}\label{lma:multi-correct}
  Consider an application of one of the rules in
  \cref{tbl:rules:multi}, with
  premises~$\SomeClause_1, \ldots, \SomeClause_k$ and
  conclusion~$\SomeClause$. An assignment~$\beta$ (over the symbols in
  $\SomeClause$) satisfies the conclusion~$\SomeClause$ if and only if
  there is an extension~$\beta' of \beta$ satisfying one of the
  premises~$\SomeClause_i$.
\end{lemma}

\begin{proof}
  We have to consider the two new rules in \cref{tbl:rules:multi}. The
  result is immediate for \ExpandM{}, since this rule does not remove the
  $\Image$ predicate from a proof goal, and the newly introduced formulas
  are all implied by the $\Image$ predicate.

  For \Materialise{}, observe that the existence of an accepting path
  in $\Automaton_i \times \Automaton_j$ is equivalent to the existence
  of individual paths in $\Automaton_i, \Automaton_j$ accepting the
  same word. The path in the product will satisfy the flow equations
  and connectedness, and it will be related to the individual paths as
  stipulated by the \BindingSum{} predicate.
\end{proof}