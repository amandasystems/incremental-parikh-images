The Parikh image is a characterisation of formal languages in terms of their
character counts. Given a language over an alphabet~$\{a_1, \ldots, a_k\}$, the
Parikh image is a set of $k$-dimensional vectors that contains some
vector~$\VectorLiteral{m_1, m_2, \ldots, m_k}$ if and only if the formal
language contains a word in which each $a_i$ occurs $m_i$ times. It is a
classical result that the Parikh image of every context-free language (and,
thus, also of every regular language) is a semilinear set~\cite{parikh-theorem},
i.e., Presburger-definable.

Parikh images play a central role in many automata-based algorithms, for
instance and notably in today's string solvers, which often have to process
constraints that combine regular language membership with word length. To decide
whether a simple formula like $x \in \Language_1 \wedge y \in \Language_2 \wedge
|x| > |y|$, with string variables~$x, y$ and regular languages~$\Language_1,
\Language_2$, is satisfiable, it is necessary to reason about the sets of word
lengths induced by $\Language_1, \Language_2$, which are special cases of the
Parikh image.  This required combined reasoning about strings and string length
has long been identified as a major bottleneck in string solvers
\cite{DBLP:conf/cav/AbdullaACHRRS15,length-aware-solver,approximate-parikh,DBLP:journals/corr/BerzishZG17}.
Other string solvers make use of Parikh automata~\cite{parikh-automata}, and
thus Parikh images in the general case, to handle operations including
\verb!str.substr!  and \verb!str.at!, which comes at an even higher price in
terms of computational complexity~\cite{ostrich-plus}.


It is possible to compute an existential Presburger formula describing the
Parikh image of any context-free language in linear
time~\cite{generate-parikh-image}; for the special case of regular languages,
this result was also stated in \cite{muscholl-linear}. While theoretically
elegant, this construction has several disadvantages, often making it
unpractical for integration into algorithms. Firstly, the constructed Presburger
formula contains a linear number of existential quantifiers in the size of the
considered grammar, as well as complex Boolean structure, which is needed to
express the connectedness of sets of productions considered in the construction.
Eliminating those quantifiers to obtain a quantifier-free representation of the
Parikh image has exponential complexity~\cite{DBLP:conf/issac/Weispfenning97},
and is often impossible in reasonable time. Just solving the Parikh image
membership problem is NP-complete, as it corresponds to computing a satisfying
assignment of the existential Presburger formula, and taxing for solvers as
well~\cite{ostrich-plus}.

Secondly, in applications involving regular languages, it is typically necessary
to consider the Parikh image not only of a single automaton, but of the
intersection of multiple automata. This problem arises in string solvers in
particular, as conjunctions of string constraints lead to the computation of
length images of products (intersections) of regular languages represented as
finite automata. Applying the approach in~\cite{generate-parikh-image} would in
this case require the eager computation of the product before its length image,
and result in an existential Presburger formula of exponential size (in the
number of automata). In several instances we have observed while solving
real-world string constraints, the computation of the product of automata
exhausts the memory of any machine available due to the exponential blow-up in
size of the product, quickly becoming intractable as the number of automata in
the product increases. The current best published mitigation for this problem is
an over-approximation that works by approximating the Parikh image of a product
of automata to be the conjunction of the image of the individual automata of the
product \cite{approximate-parikh}. This approach only works for unsatisfiable
instances, and comes with a harsh penalty for satisfiable instances.

Addressing these concerns, we have developed a calculus for Parikh images of
products of regular languages that we call \Calculus{}. It allows us to
interleave the computation of arbitrarily deep products of automata with the
product's Parikh image, and is generalised to an arbitrary homomorphism over
automata labels, including string lengths. This enables us to let both
calculations inform each other, eliminating unnecessary work, and pruning the
size of the partial products considered in the computation for a smaller memory
footprint. Moreover, the method can be used iteratively to tackle smaller chunks
of the product incrementally, thereby decreasing the memory footprint.

The key ideas of \Calculus{} is a combination of problem-aware case splitting,
lazy enforcement of automata connectivity, and lazy computation of products. In
essence, we use constraint-based methods to efficiently enforce the constraints
associated with computing Parikh images of regular languages.

We implement \Calculus{} as a plug-in theory for the \Princess{} automated
theorem prover. \Fudge{Others} have integrated it into the similarly
\Princess{}-backed string constraint solver \OstrichPlus{}, where it is used to
handle constraints that use cost-enriched automata, as described in
\cite{ostrich-plus}.

We additionally wrap the Parikh image solver as a stand-alone tool, \Catra.
\Catra{} also supports a variant of the approximate method of
\cite{approximate-parikh}, its fall-back variant adapted
from~\cite{generate-parikh-image}, and an adapter for the \Nuxmv{} model
checker~\cite{nuxmv}. Using \Catra, we compare \Calculus{} to the other two
back-ends on \NrBenchmarks{} distinct Parikh automata intersection problems
generated by \OstrichPlus{} when solving the PyEx string constraint benchmark
suite involving string length constraints \cite{pyex}.

In summary, we contribute:
\begin{itemize}
    \item The \Calculus{} calculus to efficiently compute (a homomorphism on)
          the Parikh image of products of Parikh automata.
    \item Experiments illustrating the performance of \Calculus{} on real-world
    examples from string solving, including \NrBenchmarks{} instances in a
    standardised format made available for future study.
    \item The \Catra{} tool for solving such instances, containing an
    implementation of \Calculus{}, the over-approximation described
    in~\cite{approximate-parikh}, and an adapter for the~\Nuxmv{} model
    checker~\cite{nuxmv}.
    \item Suggestions for how to efficiently implement \Calculus{} in a modern
    automated theorem prover, including strategies for case splitting, clause
    learning, and constraint propagation for connectedness.
\end{itemize}

\subsection{Related Work}

The problem of computing constraints on Parikh images over products of regular
languages under a given commutative homomorphism amounts to solving products of
Parikh automata. Parikh automata are regular automata extended with integer
counters with given increments and decrements for each transition, where we
allow checking a set of linear constraints on the final values of the counters
(but not their intermittent values) \cite{parikh-automata}. Parikh automata
without constraints on the final values on their registers are also sometimes
called cost-enriched automata, weighted automata or counter automata, depending
on exact definitions and side-constraints. The decision problem tackled in this
paper, determining the emptiness of an intersection of Parikh automata, was
recently shown to be PSPACE-complete~\cite{graph-queries}.

Parikh image computations as well as Parikh automata feature extensively in
string solvers, including as mentioned above \Ostrich{} and \OstrichPlus{}
\cite{ostrich,ostrich-plus}, but also forms the basis of Trau~\cite{trau-pldi},
and occurs in \textsc{Sloth}~\cite{sloth}. Parikh images frequently appear when
introducing cardinality constraints like length or string indexing. The
state-of-the-art approach to handling Parikh image computation is to
over-approximate the Parikh image of a product of $k$~automata
$\ParikhMap(\Language(\Automaton_1) \cap \ldots \cap \Language(\Automaton_k))$
with the conjunction of the automata's Parikh maps, $\bigwedge_{i=1}^{k}
\ParikhMap(\Automaton_i)$. This approach works only for unsatisfiable instances,
and will require falling back to computing the product of the automata before
using the standard approach for finding its image originally presented
in~\cite{generate-parikh-image}.

% @Philipp: please verify that this is not a lie!
The problem and our calculus, \Calculus{}, takes a similar approach to the work
of \citeauthor{symbolic-boolean-derivatives}, who present an orthogonal calculus
for handling a similar blow-up in complexity resulting from Boolean combinations
of regular automata in SMT string solvers \cite{symbolic-boolean-derivatives}.
In addition to presenting a decision procedure for lazily dispatching
constraints, we similarly also allow for symbolic labelling of automata to
handle large Unicode alphabets.

Outside of string solvers, Parikh automata have been proposed as the basis of
queries~\cite{graph-queries}, and for solving cardinalities in model checking
problems involving epistemic logic~\cite{epistemic-logic}.

Many other generalisations of the Parikh image than the projections we use here
have been studied. Prominent examples include generalising the Parikh map to
segments of a fixed length \cite{KARHUMAKI1980155} and the more general Parikh
matrix, which gives more information about a word than the standard Parikh image
\cite{parikh-matrix}. Another notable generalisation is the p-vector, introduced
in~\cite{infinite-words}, which denotes the position of each letter in the word
rather than the number of their occurrences and allows for generalisations into
infinite alphabets. All of these in some sense extend the Parikh map. By
contrast, the main utility of the formulation introduced here is that it allows
us to \emph{remove} something, thereby potentialy obtaining an easier problem.