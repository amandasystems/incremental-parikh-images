Extending automated theorem provers and SMT solvers with support for rich string
constraints is important for program analysis, particularly to detect cross-site
scripting vulnerabilities and other string manipulation
bugs~\cite{DBLP:books/sp/BultanYAA17}.
%
To decide whether a formula like $x \in \Language_1 \wedge y \in \Language_2
\wedge |x| > |y|$, with string variables~$x, y$ and regular
languages~$\Language_1, \Language_2$, is satisfiable, it is necessary to reason
about the sets of word lengths induced by $\Language_1, \Language_2$, which are
special cases of the Parikh image of such languages.
This required combined reasoning about
strings and string length has long been identified as a major bottleneck in
string solvers
\cite{DBLP:conf/cav/AbdullaACHRRS15,length-aware-solver,approximate-parikh,DBLP:journals/corr/BerzishZG17}.
Other string solvers make use of Parikh automata~\cite{parikh-automata}, and
thus Parikh images in the general case, to handle operations that combine
strings and integers (including
\verb!str.substr!  and \verb!str.at!), which comes at an even higher price in
terms of computational complexity~\cite{ostrich-plus}.

The Parikh image, more broadly, is a characterisation of formal languages in
terms of their character counts. Given a language over an alphabet~$\{a_1,
\ldots, a_k\}$, the Parikh image is a set of $k$-dimensional vectors that
contains some vector~$\VectorLiteral{m_1, m_2, \ldots, m_k}$ if and only if the
formal language contains a word in which each $a_i$ occurs $m_i$ times. It is a
classical result that the Parikh image of every context-free language (and,
thus, also of every regular language) is a semilinear set,
i.e., Presburger-definable~\cite{parikh-theorem}.

It is possible to compute an existential Presburger formula describing the
Parikh image of any context-free language in linear
time~\cite{generate-parikh-image}; for the special case of regular languages,
this result was also stated in \cite{muscholl-linear}. While theoretically
elegant, this construction has several disadvantages, often making it
impractical for integration into algorithms. Firstly, the constructed Presburger
formula contains a linear number of existential quantifiers in the size of the
considered grammar, as well as complex Boolean structure, which is needed to
express the connectedness of sets of productions considered in the construction.
Eliminating those quantifiers to obtain a quantifier-free representation of the
Parikh image has exponential complexity~\cite{DBLP:conf/issac/Weispfenning97},
and is often impossible in reasonable time. Just solving the Parikh image
membership problem is NP-complete, as it corresponds to computing a satisfying
assignment of the existential Presburger formula, and taxing for solvers as
well~\cite{ostrich-plus}.

Secondly, in applications involving regular languages, it is typically necessary
to consider the Parikh image not only of a single automaton, but of the
intersection of multiple automata. This problem arises in string solvers in
particular, as conjunctions of string constraints lead to the computation of
length images of products (intersections) of regular languages represented as
finite automata. Applying the approach in~\cite{generate-parikh-image} would in
this case require the eager computation of the product before its length image,
and result in an existential Presburger formula of exponential size (in the
number of automata). In several instances we have observed while solving
real-world string constraints, the computation of the product of automata
exhausts the memory of any machine available due to the exponential blow-up in
size of the product, quickly becoming intractable as the number of automata in
the product increases. The current best published mitigation for this problem is
an over-approximation that works by approximating the Parikh image of a product
of automata to be the conjunction of the image of the individual automata of the
product \cite{approximate-parikh}. This approach only works for unsatisfiable
instances, and comes with a harsh penalty for satisfiable instances.

The most basic version of the problem considered in this paper is:
{
    \centering
    \begin{tcolorbox}[colback=gray!5!white,colframe=gray!75!black,%
        title=Satisfiability of Parikh images of a product of automata,%
        width=0.8\linewidth]
        Given a finite set of regular languages, $\Language_1, \ldots, \Language_n$
        over a finite, common, alphabet $\Set{a_1, \ldots, a_k}$,
        and a Presburger formula, $\phi(\Vec{x_1, \ldots, x_k})$, 
        decide if there is a word, $w$ in the 
        intersection of $\Language_1, \ldots, \Language_n$, whose Parikh vector 
        $\Vec{m_1, \ldots, m_k}$ satisfies $\phi$.
    \end{tcolorbox}
  }

Addressing these concerns, we have developed a calculus for Parikh images of
products of regular languages that we call \Calculus{}. It allows us to
interleave the computation of arbitrarily deep products of automata with the
product's Parikh image, and is generalised to an arbitrary homomorphism over
automata labels, including string lengths. This enables us to let both
calculations inform each other, eliminating unnecessary work, and pruning the
size of the partial products considered in the computation for a smaller memory
footprint. Moreover, the method can be used iteratively to tackle smaller chunks
of the product incrementally, thereby decreasing the memory footprint.

The key ideas of \Calculus{} is a combination of problem-aware case splitting,
lazy enforcement of automata connectivity, and lazy computation of products. In
essence, we use constraint-based methods to efficiently enforce the constraints
associated with computing Parikh images of regular languages.

We implement \Calculus{} as a plug-in theory for the \Princess{} automated
theorem prover.
%
We additionally wrap the Parikh image solver as a stand-alone tool, \Catra.
\Catra{} also supports a variant of the approximate method of
\cite{approximate-parikh}, its fall-back variant adapted
from~\cite{generate-parikh-image}, and an adapter for the \Nuxmv{} model
checker~\cite{nuxmv}. Using \Catra, we compare \Calculus{} to the other two
back-ends on \NrBenchmarks{} distinct Parikh automata intersection problems
generated by \OstrichPlus{} when solving the PyEx string constraint benchmark
suite involving string length constraints \cite{pyex}.

% PR: maybe only mention this in the evaluation?

% \Fudge{Others} have integrated it into the similarly
%\Princess{}-backed string constraint solver \OstrichPlus{}, where it is used to
%handle constraints that use cost-enriched automata, as described in
%\cite{ostrich-plus}.

In summary, we contribute:
\begin{itemize}
    \item The \Calculus{} calculus to efficiently compute (a homomorphism on)
          the Parikh image of products of Parikh automata.
    \item Techniques to efficiently implement \Calculus{} in a modern
    automated theorem prover, including strategies for case splitting, clause
    learning, and constraint propagation for connectedness.
    \item The \Catra{} tool for solving such instances, containing an
    implementation of \Calculus{}, the over-approximation described
    in~\cite{approximate-parikh}, and an adapter for the~\Nuxmv{} model
    checker~\cite{nuxmv}.
    \item Experiments illustrating the performance of \Calculus{} on real-world
    examples from string solving, including \NrBenchmarks{} instances in a
    standardised format made available for future study.
\end{itemize}

\subsection{Related Work}

The problem of computing constraints on Parikh images over products of regular
languages under a given commutative homomorphism amounts to checking emptiness
of products of
Parikh automata. Parikh automata are regular automata extended with integer
counters with given increments and decrements for each transition, where we
allow checking a set of linear constraints on the final values of the counters
(but not their intermittent values) \cite{parikh-automata}. Parikh automata
without constraints on the final values on their registers are also sometimes
called cost-enriched automata, weighted automata, or counter automata, depending
on exact definitions and side constraints. The decision problem tackled in this
paper, determining the emptiness of an intersection of Parikh automata, was
recently shown to be PSPACE-complete~\cite{graph-queries}.

Parikh image computations, as well as Parikh automata, feature extensively in
string solvers, including as mentioned above \Ostrich{} and \OstrichPlus{}
\cite{ostrich,ostrich-plus}, but also forms the basis of
\textsc{Trau}~\cite{trau-pldi},
and occurs in \textsc{Sloth}~\cite{sloth}. Parikh images frequently appear when
introducing cardinality constraints like length or string indexing. The
state-of-the-art approach to handling Parikh image computation is to
over-approximate the Parikh image of a product of $k$~automata
$\ParikhMap(\Language(\Automaton_1) \cap \ldots \cap \Language(\Automaton_k))$
with the conjunction of the automata's Parikh maps, $\bigwedge_{i=1}^{k}
\ParikhMap(\Language(\Automaton_i))$. Due to the over-approximation,
this approach works only for unsatisfiable instances,
and will require falling back to computing the product of the automata before
using the standard approach for finding its image originally presented
in~\cite{generate-parikh-image}.

Our calculus~\Calculus{} is similar in spirit to the work
of \citeauthor{symbolic-boolean-derivatives}, who tackle the exponential
blow-up resulting from Boolean combinations
of regular automata in SMT string solvers
through the use of symbolic derivatives~\cite{symbolic-boolean-derivatives}.
In addition to presenting a decision procedure for lazily dispatching
constraints, we similarly also allow for symbolic labelling of automata to
handle large Unicode alphabets.

Beyond the field of string solving, Parikh image computation is used
as an elementary building block in a variety of areas.  For instance,
Parikh automata have been proposed as the basis of queries in graph
databases~\cite{graph-queries}; Parikh images are used for handling
cardinalities in parameterised model checking for epistemic
logic~\cite{epistemic-logic}; or for handling summation constraints in
expressive array logics~\cite{rodrigoRaya}. Our calculus~\Calculus{},
and the stand-alone solver~\Catra{},
are potentially useful in all such applications.

Other generalisations of the Parikh image than the projections we use here
have been studied. Prominent examples include generalising the Parikh map to
segments of a fixed length~\cite{KARHUMAKI1980155} and the more general Parikh
matrix, which contains not only the Parikh vector, but also information about
the order of letters. Another notable generalisation is the p-vector, introduced
in~\cite{infinite-words}, which denotes the position of each letter in the word
rather than the number of their occurrences and allows for generalisations into
infinite alphabets. All of these in some sense extend the Parikh map. By
contrast, the main utility of the formulation introduced here is to reason
about Parikh images \emph{lazily,}
thereby potentially obtaining answers more quickly. We expect that our
calculus~\Calculus{} can be generalised to the mentioned functions on
formal languages as well, but leave such investigations to future work.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
