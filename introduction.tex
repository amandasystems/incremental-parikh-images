Extending automated theorem provers and SMT solvers with support for rich string
constraints is important for program analysis, particularly to detect cross-site
scripting vulnerabilities and other string manipulation
bugs~\cite{DBLP:books/sp/BultanYAA17}.
%
To decide whether a formula like $x \in \Language_1 \wedge y \in \Language_2
\wedge |x| > |y|$, with string variables~$x, y$ and regular
languages~$\Language_1, \Language_2$, is satisfiable, it is necessary to reason
about the sets of word lengths induced by $\Language_1, \Language_2$, which are
special cases of the Parikh image of such languages.
This required combined reasoning about
strings and string length has long been identified as a major bottleneck in
string solvers
\cite{DBLP:conf/cav/AbdullaACHRRS15,length-aware-solver,approximate-parikh,DBLP:journals/corr/BerzishZG17}.
Other string solvers make use of Parikh automata~\cite{parikh-automata}, and
thus Parikh images in the general case, to handle operations that combine
strings and integers (including
\verb!str.substr!  and \verb!str.at!), which comes at an even higher price in
terms of computational complexity~\cite{ostrich-plus}.

The Parikh image, more broadly, is a characterisation of formal languages in
terms of their character counts. Given a language over an alphabet~$\{a_1,
\ldots, a_k\}$, the Parikh image is a set of $k$-dimensional vectors that
contains some vector~$\VectorLiteral{m_1, m_2, \ldots, m_k}$ if and only if the
formal language contains a word in which each $a_i$ occurs $m_i$ times. It is a
classical result that the Parikh image of every context-free language (and,
thus, also of every regular language) is a semilinear set,
i.e., Presburger-definable~\cite{parikh-theorem}.

In applications involving regular languages, it is typically necessary
to consider the Parikh image not only of a single automaton, but of the
intersection of multiple automata. This problem arises in string solvers in
particular, as conjunctions of string constraints lead to the computation of
length images of products (intersections) of regular languages represented as
finite automata. The problem considered in this paper is thus:

{
    \centering
    \begin{tcolorbox}[colback=gray!5!white,colframe=gray!75!black,%
        title=Satisfiability of Parikh images of a product of automata,%
        width=0.8\linewidth]
        Given a finite set of deterministic, finite-state automata, $\Automaton_1, \ldots, \Automaton_n$
        over a finite, common, alphabet $\Set{a_1, \ldots, a_k}$,
        and a Presburger formula, $\phi(\VectorLiteral{x_1, \ldots, x_k})$, 
        decide if there is a word, $w$ accepted by the 
        product $\Automaton_1 \times \cdots \times \Automaton_n$, whose Parikh vector 
        $\VectorLiteral{m_1, \ldots, m_k}$ satisfies $\phi$.
    \end{tcolorbox}
  }

  The current method of handling this problem consists of computing the
  intersection of the languages (the product of their automata),
  constructing the Presburger representation of their Parikh image, and then
  checking its satisfiability. It is possible to compute an existential
   Presburger formula describing the
  Parikh image of any \emph{context-free} language in linear
  time~\cite{generate-parikh-image}. For our special case of regular languages,
  this result was also stated in~\cite{muscholl-linear}. While theoretically
  elegant, this construction has several disadvantages for us, often making it
  impractical for integration into algorithms.
  
  Firstly, the constructed Presburger
  formula contains a linear number of existential quantifiers in the size of the
  considered grammar, as well as complex Boolean structure, which is needed to
  express the connectedness of sets of productions considered in the construction.%
  \iffalse{}Eliminating those quantifiers to obtain a quantifier-free representation of the
  Parikh image has exponential complexity~\cite{DBLP:conf/issac/Weispfenning97},
  and is often impossible in reasonable time.\fi{}%
  Just solving the Parikh image
  membership problem is NP-complete, as it corresponds to computing a satisfying
  assignment of the existential Presburger formula, and taxing for solvers as
  well~\cite{ostrich-plus}.
  
  Secondly, computing the product itself is usually prohibitively expensive
  in both memory and CPU due to exponential blow-up. Applying the approach in~\cite{generate-parikh-image} would in
  this case require the eager computation of the product before its length image,
  and result in an existential Presburger formula of exponential size (in the
  number of automata). In several instances we have observed while solving
  real-world string constraints, the computation of the product of automata
  exhausts the memory of any machine available due to the exponential blow-up in
  size of the product, quickly becoming intractable as the number of automata in
  the product increases.
  
  The current best published mitigation for this problem relies on the observation
  that any Presburger formula that applies to a product of automata must also hold
  for all of the terms of that product individually. Exploiting this fact, the Parikh
  image of a product of automata is first represented as the conjunction of the image of
  the individual automata of the product, falling back to computing the entire product
  for satisfiable cases or cases when unsatisfiability is only discoverable after
  full- or partial product construction~\cite{approximate-parikh}.


Addressing these concerns, we have developed a calculus for Parikh images of
products of regular languages that we call \Calculus{}. It allows us to
interleave the computation of arbitrarily deep products of automata with the
product's Parikh image, and is generalised to an arbitrary homomorphism over
automata labels, including string lengths. This enables us to let both
calculations inform each other, eliminating unnecessary work, and pruning the
size of the partial products considered in the computation for a smaller memory
footprint. Moreover, our approach allows us to do this precisely, without the expensive
fallbacks when approximations fail as in the case of~\cite{approximate-parikh}.

Our primary influence for this work is the operation of (finite-domain) 
constraint programming (CP)%
~solvers~\cite{cp}. CP~solvers typically employ a combination of lazy enforcement
of constraints through \emph{propagation},
pruning values from decision variable domains that do not satisfy 
the constraints during solving, and \emph{branching}, splitting proofs
by cases in a way that will encourage maximum propagation.

For our problem, the constraints are automata connectivity and linear
equations (Presburger formulas).
We use propagation to lazily enforce connectivity of automata,
removing transitions as they become unreachable during solving or are
eliminated by constraints in the Presburger formula. We
also branch on the presence or absence of transitions to
encourage propagation of the connectivity constraint. This allows
us to whittle down the automata
(including intermittent products) before moving on with potentially
 explosive product construction. The underlying observation
is that though the domain of our integer variables
is infinite, the number of simple paths
through the automata (and their product) is finite. In summary, the key ideas are:

{
    \centering
    \begin{tcolorbox}[colback=ourcolour!5!white,colframe=ourcolour!75!black,%
        title=Key ideas of \Calculus{},%
        width=0.8\linewidth]

        \begin{itemize}
            \item Enforce automata connectivity constraints lazily
            \item Use \emph{propagation} of constraints on the Parikh image to prune
            transitions from the automata that are incompatible with constraints
            \item Intelligently \emph{branch} on the presence\slash{}absence of key
             transitions to drive propagation of the connectivity constraint
             \item Compute products of automata lazily, after pruning transitions
             that violate constraints using propagation
        \end{itemize}
    \end{tcolorbox}
  }


We implement \Calculus{} as a plug-in theory for the \Princess{} automated
theorem prover and experimentally use it as the Parikh image interesection solver for
to the \Ostrich{} string constraint solver.

We additionally wrap the Parikh image solver as a stand-alone tool, \Catra{}.
\Catra{} also supports a variant of the approximate method of~\cite{approximate-parikh}, its fall-back variant adapted
from~\cite{generate-parikh-image}, and an adapter for the \Nuxmv{} model
checker~\cite{nuxmv}. Using \Catra, we compare \Calculus{} to the other two
back-ends on \NrBenchmarks{} distinct Parikh automata intersection problems
generated by \OstrichPlus{} when solving the PyEx string constraint benchmark
suite involving string length constraints~\cite{pyex}, finding that \Calculus{}
outperforms both \Nuxmv{} and the baseline method, allowing \Calculus{}
to solve every problem solved by baseline within \SI{30}{s} in under \SI{5}{s}.
\Calculus{} in particular outperforms \Nuxmv{} on unsatisfiable instances, more than 
doubling the number of unsatisfiable results found within a \SI{30}{s}~timeout.

We extend the \Ostrich{} string solver's backend portfolio with \Calculus{} via
\Catra{} as the Parikh image intersection solver of the \OstrichPlus{}~algorithm,
obtaining improvements in both \textsc{Sat}  and \textsc{Unsat} performance in
\Ostrich{}' results from SMT-COMP 2023, crucially allowing \Ostrich{} to win
the unsatisfiable category of the track of quantifier-free, linear constraints
over string logic (QF\_SLIA) and increasing the number of \textsc{Sat}~results
by \numprint{3}\% on the same track.

% PR: maybe only mention this in the evaluation?

% \Fudge{Others} have integrated it into the similarly
%\Princess{}-backed string constraint solver \OstrichPlus{}, where it is used to
%handle constraints that use cost-enriched automata, as described in
%\cite{ostrich-plus}.

In summary, we contribute:
\begin{itemize}
    \item The \Calculus{} calculus to efficiently compute (a homomorphism on)
          the Parikh image of products of Parikh automata.
    \item Techniques to efficiently implement \Calculus{} in a modern
    automated theorem prover, including strategies for case splitting, clause
    learning, and constraint propagation for connectedness.
    \item The \Catra{} tool for solving such instances, containing an
    implementation of \Calculus{}, the over-approximation described
    in~\cite{approximate-parikh}, and an adapter for the~\Nuxmv{} model
    checker~\cite{nuxmv}.
    \item Experiments illustrating the performance of \Calculus{} on real-world
    examples from string solving, including \NrBenchmarks{} instances in a
    standardised format made available for future study.
\end{itemize}

\subsection{Related Work}

The problem of computing constraints on Parikh images over products of regular
languages under a given commutative homomorphism amounts to checking emptiness
of products of
Parikh automata. Parikh automata are regular automata extended with integer
counters with given increments and decrements for each transition, where we
allow checking a set of linear constraints on the final values of the counters
(but not their intermittent values) \cite{parikh-automata}. Parikh automata
without constraints on the final values on their registers are also sometimes
called cost-enriched automata, weighted automata, or counter automata, depending
on exact definitions and side constraints. The decision problem tackled in this
paper, determining the emptiness of an intersection of Parikh automata, was
recently shown to be PSPACE-complete~\cite{graph-queries}.

Parikh image computations, as well as Parikh automata, feature extensively in
string solvers, including as mentioned above \Ostrich{} and \OstrichPlus{}
\cite{ostrich,ostrich-plus}, but also forms the basis of
\textsc{Trau}~\cite{trau-pldi},
and occurs in \textsc{Sloth}~\cite{sloth}. Parikh images frequently appear when
introducing cardinality constraints like length or string indexing. The
state-of-the-art approach to handling Parikh image computation is to
over-approximate the Parikh image of a product of $k$~automata
$\ParikhMap(\Language(\Automaton_1) \cap \ldots \cap \Language(\Automaton_k))$
with the conjunction of the automata's Parikh maps, $\bigwedge_{i=1}^{k}
\ParikhMap(\Language(\Automaton_i))$. Due to the over-approximation,
this approach works only for unsatisfiable instances,
and will require falling back to computing the product of the automata before
using the standard approach for finding its image originally presented
in~\cite{generate-parikh-image}.

Our calculus~\Calculus{} is similar in spirit to the work
of \citeauthor{symbolic-boolean-derivatives}, who tackle the exponential
blow-up resulting from Boolean combinations
of regular automata in SMT string solvers
through the use of symbolic derivatives~\cite{symbolic-boolean-derivatives}.
In addition to presenting a decision procedure for lazily dispatching
constraints, we similarly also allow for symbolic labelling of automata to
handle large Unicode alphabets.

Beyond the field of string solving, Parikh image computation is used
as an elementary building block in a variety of areas.  For instance,
Parikh automata have been proposed as the basis of queries in graph
databases~\cite{graph-queries}; Parikh images are used for handling
cardinalities in parameterised model checking for epistemic
logic~\cite{epistemic-logic}; or for handling summation constraints in
expressive array logics~\cite{rodrigoRaya}. Our calculus~\Calculus{},
and the stand-alone solver~\Catra{},
are potentially useful in all such applications.

Other generalisations of the Parikh image than the projections we use here
have been studied. Prominent examples include generalising the Parikh map to
segments of a fixed length~\cite{KARHUMAKI1980155} and the more general Parikh
matrix, which contains not only the Parikh vector, but also information about
the order of letters. Another notable generalisation is the p-vector, introduced
in~\cite{infinite-words}, which denotes the position of each letter in the word
rather than the number of their occurrences and allows for generalisations into
infinite alphabets. All of these in some sense extend the Parikh map. By
contrast, the main utility of the formulation introduced here is to reason
about Parikh images \emph{lazily,}
thereby potentially obtaining answers more quickly. We expect that our
calculus~\Calculus{} can be generalised to the mentioned functions on
formal languages as well, but leave such investigations to future work.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
